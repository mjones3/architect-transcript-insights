import axios from 'axios';
import { TranscriptEntry, MeetingSummary } from '../types';
import { uploadToClaudeProjects } from './ai';

const API_BASE_URL = 'http://localhost:3001/api';

export async function saveTranscript(
  transcript: TranscriptEntry[],
  summary: MeetingSummary | null,
  projectIds: string[]
): Promise<void> {
  const timestamp = new Date().toISOString();
  const filename = `meeting-transcript-${timestamp.replace(/[:.]/g, '-')}.md`;

  const markdownContent = generateMarkdown(transcript, summary, projectIds, true); // true for full transcript

  try {
    // Save to S3
    await axios.post(`${API_BASE_URL}/save`, {
      filename,
      content: markdownContent,
      projectIds,
      metadata: {
        timestamp,
        speakerCount: new Set(transcript.map(e => e.speaker)).size,
        duration: calculateDuration(transcript),
        hasArchitectureItems: summary?.architectureItems && summary.architectureItems.length > 0
      }
    });
    
    // Upload full transcript to Claude Projects
    await uploadToClaudeProjects(transcript, summary, projectIds);
    
  } catch (error) {
    console.error('Failed to save transcript:', error);
    // For development, save locally
    downloadMarkdown(filename, markdownContent);
  }
}

function generateMarkdown(
  transcript: TranscriptEntry[],
  summary: MeetingSummary | null,
  projectIds: string[],
  includeFullTranscript: boolean = true
): string {
  const timestamp = new Date().toISOString();
  let markdown = `# Meeting Transcript\n\n`;
  markdown += `**Date:** ${new Date(timestamp).toLocaleString()}\n\n`;
  markdown += `**Projects:** ${projectIds.join(', ')}\n\n`;

  if (summary) {
    markdown += `## Summary\n\n`;
    
    markdown += `### Key Points\n\n`;
    summary.keyPoints.forEach(point => {
      markdown += `- ${point}\n`;
    });
    markdown += '\n';

    if (summary.architectureItems.length > 0) {
      markdown += `### Architecture Considerations\n\n`;
      summary.architectureItems.forEach(item => {
        markdown += `#### **${item.title}** (${item.type}${item.priority ? ` - ${item.priority} priority` : ''})\n\n`;
        markdown += `${item.description}\n\n`;
      });
    }

    if (summary.actionItems.length > 0) {
      markdown += `### Action Items\n\n`;
      summary.actionItems.forEach(item => {
        const prefix = item.isArchitectureRelated ? '**[ARCHITECTURE]**' : '';
        const assignee = item.assignee ? ` - @${item.assignee}` : '';
        const due = item.dueDate ? ` (Due: ${new Date(item.dueDate).toLocaleDateString()})` : '';
        markdown += `- ${prefix} ${item.title}${assignee}${due}\n`;
      });
      markdown += '\n';
    }
  }

  markdown += `## Full Transcript\n\n`;
  transcript.forEach(entry => {
    const time = new Date(entry.timestamp).toLocaleTimeString();
    markdown += `**[${time}] ${entry.speaker}:**\n${entry.text}\n\n`;
  });

  markdown += `---\n\n`;
  markdown += `*Generated by Architect Transcript Insights on ${new Date().toLocaleString()}*\n`;

  return markdown;
}

function calculateDuration(transcript: TranscriptEntry[]): number {
  if (transcript.length < 2) return 0;
  
  const start = new Date(transcript[0].timestamp).getTime();
  const end = new Date(transcript[transcript.length - 1].timestamp).getTime();
  
  return Math.floor((end - start) / 1000); // Duration in seconds
}

function downloadMarkdown(filename: string, content: string) {
  const blob = new Blob([content], { type: 'text/markdown' });
  const url = URL.createObjectURL(blob);
  const link = document.createElement('a');
  link.href = url;
  link.download = filename;
  link.click();
  URL.revokeObjectURL(url);
}